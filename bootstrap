#!/usr/bin/env python

"""
Bootstrap dotfiles
"""

from __future__ import print_function
import os
import platform
from subprocess import check_call, CalledProcessError, DEVNULL
import sys


def _is_ansi_linux():
    return hasattr(sys.stderr, "isatty") and sys.stderr.isatty() and not platform.system() == 'Windows'


def _print_error(err):
    if _is_ansi_linux():
        print("\033[1;31m%s\033[1;m" % err)
    else:
        print(err)


def _print_already_exists(path):
    msg = "error: symlink or file already exists: %s" % path
    if _is_ansi_linux():
        print("\033[1;35m%s\033[1;m" % msg)
    else:
        print(msg)


def _print_msg(msg):
    if _is_ansi_linux():
        print("\033[1;34m%s\033[1;m" % msg)
    else:
        print(msg)


def main():
    """
    main
    """
    top_level_dir_list = [f for f in os.listdir('.') if os.path.isdir(f) and not f.startswith('.')]

    progs_exist_list = []
    for prog in top_level_dir_list:
        try:
            check_call(["which", prog], stdout=DEVNULL, stderr=DEVNULL)
        except CalledProcessError:
            _print_error("error: executable not found: %s" % prog)
        else:
            progs_exist_list.append(prog)

    home = os.getenv("HOME")
    # TODO: figure out how to deal with .config
    for i in ['dunst', 'vim', 'termite']:
        progs_exist_list.remove(i)
    for directory in progs_exist_list:
        file_list = [f for f in os.listdir(directory)]
        for item in file_list:
            path = os.path.join(home, item)
            if os.path.islink(path) or os.path.isfile(path):
                _print_already_exists(path)
            else:
                source = os.path.realpath(os.path.join(os.getcwd(), directory, item))
                _print_msg("Creating symlink: %s" % path)
                os.symlink(source, path)

if __name__ == "__main__":
    main()
